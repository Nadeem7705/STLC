# -----------------------------------------------------------------------------
#  STLC
#
#  Copyright Â© 2022: Sartorius
#
#  All rights reserved. This program and the accompanying materials
#  are made available under the terms of the GNU Public License v3
#  which accompanies this distribution, and
#  is available at http://www.gnu.org/licenses/gpl.html
# -----------------------------------------------------------------------------

"""A module which implements the lumped kinetic model.

This module implements the lumped kinetic model, a simplified version of the
general rate model of chromatography. A model is generated by creating a
``ModelParameters`` dataclass with the specific parameters for a 
component you wish to model. The parameters struct is passed together with 
more integration parameters into the ``LumpedKineticModel`` class to generate a
model object. The model object is passed into the solve function
where the integration parameters are chosen. 

The governing equations are given by:

.. math::
    u\\frac{\\partial c_i}{\\partial z} + \\frac{\\partial c_i}{\\partial t} + \\frac{1-\\epsilon_c}{\\epsilon_c}\\frac{\\partial q_i}{\\partial t} = D_L \\frac{\\partial^2 c_i}{\\partial z^2},

Here `c` is concentration, `q` is solute concentration in stationary phase,
`u` is flow rate, `F` phase ratio `k` is adsorption rate, `q*` some function
of `c`. When discretized using orthogonal collocation we substitute the spatial
derivatives with linear operators `A` and `B` as follows,

.. math::
    \\frac{dc_i}{dt} &= DB_{ij}c_i - uA_{ij}c_i - F\\frac{dq_i}{dt},

    \\frac{dq_i}{dt} &= k(c_ia-q_i).

Then to integrate the system, we define the matrix, `M = DB - uA`, and set up
the following system:

.. math::
    q_i' = k(c_ia-q_i),

    c_i' = c_i \\cdot M_{ij}-Fq_i'.

The system is the integrated in time the `improved Euler` method.

Example
------
First create the parameter object for the model. In this case we wish to 
generate a `lumped kinetic model` and as such we use the 
``ModelParameters`` dataclass to generate the parameters::

    zl = 1.
    epsilon = 0.4
    u = 0.29
    tmax = 20
    a = 0.85
    D = 1e-4
    k = 111
    c_0 = 1
    b = 0

    parameters = lkm.ModelParameters(u=u,
                                                   ep=epsilon,
                                                   D=D,
                                                   c0=c_0,
                                                   k=k,
                                                   a=a,
                                                   b=b)

By passing the ``ModelParameters`` object, the amount 
of discretization elements `ne`, the number of points per element `n`,
and length of the column `zl` into the ``LumpedKineticModel`` class.
A ``Model`` object is returned::

    n = 7
    ne = 10
    dt = 0.001
    model = lkm.LumpedKineticModel(n, ne, zl, [parameters0])

The model object can be passed to the solve function together with the
time step and simulation time to generate a solution::

    y = lkm.solve(model, tmax, dt)

The state vector is returned indexed by every timestep.

"""

from dataclasses import dataclass, field
from typing import Callable, List, Optional
import numpy as np
from scipy.sparse import csc_matrix
from scipy.sparse import linalg as sla
from stlc import occ


@dataclass
class ModelParameters:
    """Parameters for the Lumped Kinetic model.

    Parameters
    ----------

    u : float
        Linear flow velocity.
    ep: float
        Porosity
    D : float
        Dispersion coefficient.
    c0 : float
        Inlet solute concentration.
    k : float
        Mass transfer coefficient.
    a : float
        Henrys coefficient for linear isotherm.
    b : float
        Langmuir coefficient
    ip : Optional[Callable]
        Injection profile function. Should be a reference to a function which
        determines the scale of the input c0 as a function of time. Can be
        `None` resulting in a constant injection.
    """

    u: float
    ep: float
    D: float
    c0: float
    k: float
    a: float
    b: float
    ip: Optional[Callable[[float], float]] = None


@dataclass
class LumpedKineticModel:
    """Lumped Kinetic Model
    This class will inititalize a lumped kinetic model object. This includes
    creating and scaling the differentation matrices using collocation,
    creating arrays for the component parameters and assinging variables to
    indices for use in later calculations. If more then one element `ne` is
    chosen the domain will be partitioned into finite elements.

    Parameters
    ----------

    n : int
        Discretization points per element, note that two points are added for
        boundaries.
    ne: int
        Number of elements domain is partitioned into.
    zl : float
        The column length
    parameters : List[ModelParameters]
        List containing a parameter object for each component to be modeled
    n2: int
        Number of discretization points per element including boundary points
    nz: int
        Total number of points along z-axis excluding boundary points
    nc: int
        Number of components
    nz2: int
        Total number of points along z-axis excluding boundary points
    u: np.ndarray
        Array of flow rate for each component
    ep: np.ndarray
        Array of porosity for each component
    D: np.ndarray
        Array of dispersion for each component
    c0: np.ndarray
        Array of initial inlet concentration for each component
    k: np.ndarray
        Array of mass transfer coefficients for each component
    a: np.ndarray
        Array of Henrys coefficients for each component
    b: np.ndarray
        Array of Langmuir b coefficients for each component
    A: np.ndarray
        First derivative differentation matrix
    B: np.ndarray
        Second derivative differentation matrix
    z: np.ndarray
        Collocation points scaled [0,1]
    zs: np.ndarray
        All global points
    ks: np.ndarray
        Element boundaries equispaced
    dxk: float
        Element spacing
    y_len: int
        Length of state vector
    c_inj: int
        Index of first component injection point
    c_idx: int
        Index of first component first point in column
    c_end: int
        Index of first component final point in column
    q_idx: int
        Index of first component first point stationary phase
    q_end: int
        Index of first component last point stationary phase

    """

    n: int
    ne: int
    zl: float
    parameters: List[ModelParameters]
    n2: int = field(init=False)
    nz: int = field(init=False)
    nc: int = field(init=False)
    nz2: int = field(init=False)
    u: np.ndarray = field(init=False)
    ep: np.ndarray = field(init=False)
    D: np.ndarray = field(init=False)
    c0: np.ndarray = field(init=False)
    k: np.ndarray = field(init=False)
    a: np.ndarray = field(init=False)
    b: np.ndarray = field(init=False)
    A: np.ndarray = field(init=False)
    B: np.ndarray = field(init=False)
    W: np.ndarray = field(init=False)
    z: np.ndarray = field(init=False)
    zs: np.ndarray = field(init=False)
    ks: np.ndarray = field(init=False)
    dxk: float = field(init=False)
    y_len: int = field(init=False)
    c_inj: int = field(init=False)
    c_idx: int = field(init=False)
    c_end: int = field(init=False)
    q_idx: int = field(init=False)
    q_end: int = field(init=False)

    def __post_init__(self) -> None:
        """Assign component parameters and generate differentation matrices"""
        self.n2 = self.n + 2
        self.nz2 = self.ne * (self.n + 1) + 1
        self.nz = self.nz2 - 2
        self.nc = len(self.parameters)
        self.c0 = np.zeros(self.nc)
        self.ep = np.zeros(self.nc)
        self.u = np.zeros(self.nc)
        self.D = np.zeros(self.nc)
        self.k = np.zeros(self.nc)
        self.a = np.zeros(self.nc)
        self.b = np.zeros(self.nc)
        self.ip = []
        for i in range(self.nc):
            self.c0[i] = self.parameters[i].c0
            self.ep[i] = self.parameters[i].ep
            self.u[i] = self.parameters[i].u
            self.D[i] = self.parameters[i].D
            self.k[i] = self.parameters[i].k
            self.a[i] = self.parameters[i].a
            self.b[i] = self.parameters[i].b
            if self.parameters[i].ip:
                self.ip.append(self.parameters[i].ip)
        self.y_len = self.nc + 2 * self.nc * self.nz2
        self.c_inj = 0
        self.c_idx = 1
        self.c_end = self.c_idx + self.nz2
        self.q_idx = self.c_end
        self.q_end = self.c_end + self.nz2
        self.zs = np.zeros(self.nz2)
        self.ks = np.linspace(0, self.zl, self.ne + 1)
        self.dxk = self.ks[1] - self.ks[0]
        """Inititalize collocation after variable assignments."""
        oc = occ.OrthColloc(
            n=self.n,
            TType=occ.Typ.Gauss.value,
            Geometry=occ.Geom.Nonsymmetric.value,
            Shift=True,
        )
        self.z = oc.Xpoints()
        self.A = oc.Deriv1() / self.dxk
        self.B = oc.Deriv2() / self.dxk**2

        if self.ne > 1:
            for k in range(0, self.ne):
                for j in range(0, self.n + 1):
                    self.zs[k * (self.n + 1) + j] = self.ks[k] + self.z[j] * self.dxk
            self.zs[-1] = self.zl
        else:
            self.zs = self.z * self.zl


def _calc_qstar(model: LumpedKineticModel, yt: np.ndarray, i: int) -> np.ndarray:
    """Calculates the adsorption isotherm for the ith component.

    The equation for the Langmuir adsorption isotherm are given by:

    .. math::
        q^*_i = \\frac{a_ic_i}{1+\\sum_{\\hat i}^{N_c}b_{\\hat i}c_{\\hat i}},

    For single components and dilute systems the isotherm it reduces to,

    .. math::
        q_i \\approx a_ic_i,

    Parameters
    __________

    model : LumpedKineticModel
        A Lumped kinetic model object
    yt : ndarray
        State vector for timestep ``t``
    i : int
        The component for which to calculate the adsorption

    Returns
    -------

    np.ndarray
        Vector for q*

    """

    total = np.zeros((model.nz2, model.nz2))
    for j in range(model.nc):
        cj = np.diag(yt[model.q_end * j + model.c_idx : model.q_end * j + model.c_end])
        total += model.b[j] * cj
    calc_qstar = np.diag(model.a[i] / (1 + np.diag(total)))
    return calc_qstar


def _create_state_vector(model: LumpedKineticModel, timesteps: int) -> np.ndarray:
    """Creates an empty state vector

    Parameters
    __________

    model : LumpedKineticModel
        A Lumped kinetic model object
    timesteps : int
        Total timesteps for discretized domain

    Returns
    -------

    np.ndarray
        State vector

    """
    return np.zeros((model.y_len, timesteps))


def _build_column_interior_matrix(i: int, model: LumpedKineticModel) -> np.ndarray:
    """Builds right hand side matrix for ith component

    Parameters
    __________

    i : int
        Index of component
    model : LumpedKineticModel
        A Lumped kinetic model object

    Returns
    -------

    np.ndarray
        Right hand side matrix for ith component

    """
    M = np.zeros((model.nz2, model.nz2))
    mass_transfer_terms = model.D[i] * model.B - model.u[i] * model.A

    for e in range(model.ne - 1):
        M[
            e * (model.n2 - 1) + 1 : e * (model.n2 - 1) + model.n2 - 1,
            e * (model.n2 - 1) : e * (model.n2 - 1) + model.n2,
        ] = mass_transfer_terms[1 : model.n + 1, :]

        M[
            e * (model.n2 - 1) + model.n2 - 1,
            e * (model.n2 - 1) : e * (model.n2 - 1) + model.n2,
        ] = (
            model.D[i] * model.A[-1, :] / model.u[i]
        )
        M[
            e * (model.n2 - 1) + model.n2 - 1,
            (e + 1) * (model.n2 - 1) : (e + 1) * (model.n2 - 1) + model.n2,
        ] -= (
            model.D[i] * model.A[0, :] / model.u[i]
        )

    M[
        (model.ne - 1) * (model.n2 - 1)
        + 1 : (model.ne - 1) * (model.n2 - 1)
        + model.n2
        - 1,
        (model.ne - 1) * (model.n2 - 1) : (model.ne - 1) * (model.n2 - 1) + model.n2,
    ] = mass_transfer_terms[1 : model.n + 1, :]

    M[0, 1 : model.n + 2] = model.D[i] * model.A[0, 1:] / model.u[i]
    M[0, 0] = -1 + model.D[i] * model.A[0, 0] / model.u[i]
    M[-1, -model.n - 2 :] = -model.A[-1, :]

    return M


def _assemble_complete_matrix(model: LumpedKineticModel, yt: np.ndarray) -> np.ndarray:
    """Assemble complete matrix for column discretization and stationary
    phase transfer.

    First a matrix C is created MxM with size of the state vector. A matrix M
    created for each component is created for the column interior and copied
    to C. Matric Qcstar and Qc define the Langmuir isotherm.

    Parameters
    __________

    model : LumpedKineticModel
        A Lumped kinetic model object
    yt : ndarray
        State vector for current timestep

    Returns
    -------

    np.ndarray
        Complete rhs matrix

    """
    C = np.zeros((model.y_len, model.y_len))
    for i in range(0, model.nc):
        M = _build_column_interior_matrix(i, model)
        qstar = _calc_qstar(model, yt, i)

        C[
            model.q_end * i + model.c_idx : model.q_end * i + model.c_end,
            model.q_end * i + model.c_idx : model.q_end * i + model.c_end,
        ] = M.copy()
        C[model.c_idx + model.q_end * i, model.q_end * i] = 1.0

        Qcstar = -(model.k[i] / model.ep[i]) * qstar

        Qcstar[0, :] = 0
        Qcstar[-1, :] = 0
        Qc = np.eye(model.nz2) * model.k[i] / model.ep[i]
        Qc[0, :] = 0
        Qc[-1, :] = 0

        for e in range(model.ne):
            Qcstar[
                e * (model.n2 - 1) + model.n2 - 1,
                e * (model.n2 - 1) : e * (model.n2 - 1) + model.n2,
            ] = 0
            Qc[
                e * (model.n2 - 1) + model.n2 - 1,
                (e + 1) * (model.n2 - 1) : (e + 1) * (model.n2 - 1) + model.n2,
            ] = 0

        C[
            model.q_end * i + model.c_idx : model.q_end * i + model.c_end,
            model.q_end * i + model.c_idx : model.q_end * i + model.c_end,
        ] += Qcstar

        C[
            model.q_end * i + model.c_idx : model.q_end * i + model.c_end,
            model.q_end * i + model.q_idx : model.q_end * i + model.q_end,
        ] += Qc
        """Matrix for the solid phase concentration q"""
        Qqstar = (model.k[i] / (1 - model.ep[i])) * qstar
        Qq = -np.eye(model.nz2) * model.k[i] / (1 - model.ep[i])
        C[
            model.q_end * i + model.q_idx : model.q_end * i + model.q_end,
            model.q_end * i + model.c_idx : model.q_end * i + model.c_end,
        ] = Qqstar

        C[
            model.q_end * i + model.q_idx : model.q_end * i + model.q_end,
            model.q_end * i + model.q_idx : model.q_end * i + model.q_end,
        ] = Qq
    return C


def _create_lhs_matrix(model: LumpedKineticModel, dt: float) -> np.ndarray:
    """Builds left hand side matrix for completed rhs matrix

    Parameters
    __________

    dt : float
        Timestep
    model : LumpedKineticModel
        A Lumped kinetic model object

    Returns
    -------

    np.ndarray
        State vector

    """

    C = np.zeros((model.y_len, model.y_len))

    for i in range(0, model.nc):
        J = np.eye(2 * model.nz2 + 1) / dt
        J[model.c_idx, :] = 0
        J[model.c_end - 1, :] = 0
        for e in range(model.ne):
            J[model.c_idx + e * (model.n2 - 1) + model.n2 - 1, :] = 0

        C[
            model.q_end * i + model.c_inj : model.q_end * (i + 1),
            model.q_end * i + model.c_inj : model.q_end * (i + 1),
        ] = J.copy()
    return C


def solve(model: LumpedKineticModel, tmax: float, dt: float) -> np.ndarray:
    """Solves system of equations using a improved Euler method

    Inititalizes a state vector for all timesteps and all variables,
    builds complete system matrix for rhs and lhs. Iterates over timesteps
    and solves system. If an injection profile has been provided it will be
    used else a constant injection will be used. If multiple components have
    been specified then the rhs will be recalculated each timestep.


    Parameters
    __________

    model : LumpedKineticModel
        A Lumped kinetic model object
    tmax :
        Number of total timesteps
    dt : float
        Timestep

    Returns
    -------

    np.ndarray
        Solution state vector

    """
    timesteps = int(tmax / dt)
    y = _create_state_vector(model, timesteps)
    Wh = _create_lhs_matrix(model, dt)
    Wh = csc_matrix(Wh)
    C = _assemble_complete_matrix(model, y[:, 0])
    C = csc_matrix(C)
    J = sla.splu(Wh - C)
    for t in range(1, timesteps):
        for i in range(model.nc):
            if model.ip and i < len(model.ip) and isinstance(model.ip[i], Callable):
                y[model.c_inj + i * model.q_end, t - 1] = (
                    model.ip[i]((t - 1) * dt) * model.c0[i]
                )
            else:
                y[model.c_inj + i * model.q_end, t - 1] = model.c0[i]
        if model.nc > 1:
            C = _assemble_complete_matrix(model, y[:, t - 1])
            C = csc_matrix(C)
            J = sla.splu(Wh - C)

        r = C.dot(y[:, t - 1])
        ydot = J.solve(r)
        y[:, t] = y[:, t - 1] + ydot
    return y
