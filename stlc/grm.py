# -----------------------------------------------------------------------------
#  STLC
#
#  Copyright Â© 2022: Sartorius
#
#  All rights reserved. This program and the accompanying materials
#  are made available under the terms of the GNU Public License v3
#  which accompanies this distribution, and
#  is available at http://www.gnu.org/licenses/gpl.html
# -----------------------------------------------------------------------------


"""A module which implements the General Rate model.

This module implements the general rate model, A model is generated by creating a
``LumpedKineticModelParameters`` dataclass with the specific parameters for a 
component you wish to model. The parameters struct is passed together with 
more integration parameters into the ``LumpedKineticModel`` class to generate a
model object. The model object is passed into the solve function
where the integration parameters are chosen. 

The governing equations are given by:

.. math::
    \\frac{\\partial c_i}{\\partial t} = D_{ax} \\frac{\\partial^2 c_i}{\\partial z^2} - u\\frac{\\partial c_i}{\\partial z} -  \\frac{1- \\epsilon_c}{\\epsilon_c}\\frac{3}{R_p}k_{f,i}\\left(c_i-c_{p,i}\\big|_{r=R_p}\\right)

.. math::
    \\frac{\\partial c_{p,i}}{\\partial t} = D_{p}\\left(\\frac{\\partial^2 c_{p,i}}{\\partial r^2} +\\frac{2}{r} \\frac{\\partial c_{p,i}}{\\partial r}\\right) - \\frac{\\epsilon_p}{1-\\epsilon_p}\\frac{\\partial q_i}{\\partial t}

The system is the integrated in time with the `improved Euler` method.

Example
------

First create the parameter object for the model. In this case we wish to 
generate a `General rate model` and as such we use the 
``GeneralRateModel`` dataclass to generate the parameters::

    cm = 1e-2
    minute = 60
    zl = 1.7 * cm  #[cm]
    rp = 0.004 * cm  #[cm]
    ec = 0.4
    ep = 0.333
    kf = 0.01 * cm  #[cm]
    Dax = 0.002 * cm**2 / minute  #[cm^2 min^-1]
    Dp = 3.003 * 1e-6 * cm**2 / minute  #[cm^2 min^-1]
    Ds = 0.  #[cm^2 min^-1]
    u = 0.6 * cm / minute  #[cm min^-1]
    ka = 2.5  #[s^-1]
    kd = 1  #[s^-1]
    tinj = 20 * minute  #[min]
    cinj = 1  #[mol /m^-3]
    tmax = 100 * minute  #[min]
    qm = 1.
    nr = 10
    nz = 20
    dt = 1

First create the parameter object for the model. In this case we wish to 
generate a `General rate model` and as such we use the 
``ModelParameters`` dataclass to generate the parameters::

    def step(t: float, tinj: float) -> float:
        return float(t <= tinj)

    parameters0 = grm.ModelParameters(c0=cinj,
                                      Dax=Dax,
                                        Dp=Dp,
                                        Ds=Ds,
                                        ka=ka,
                                        kd=kd,
                                        kf=kf,
                                        qm=qm,
                                        ip=lambda t: step(t, tinj))

By passing the ``ModelParameters`` object, the number of points `n`,
and length of the column `zl` into the ``ModelParameters`` class.
A ``Model`` object is returned::


    model = grm.GeneralRateModel(u=u,
                                         ep=ep,
                                         ec=ec,
                                         zl=zl,
                                         rp=rp,
                                         nz=nz,
                                         nr=nr,
                                         component_parameters=[parameters0])

The model object can be passed to the solve function together with the
time step and simulation time to generate a solution::

    sol = grm.solve(model, tmax, dt)

"""

from dataclasses import dataclass, field
from typing import Callable, List, Optional

import numpy as np
from scipy.sparse import csc_matrix, linalg

import stlc.occ as occ


@dataclass
class ModelParameters:
    """Parameters for the General Rate model.

    Parameters
    ----------

    c0 : float
        Inlet solute concentration.
    Dax : float
        Dispersion coefficient.
    Dp : float
        Dispersion coefficient.
    ka : float
        Mass transfer coefficient.
    kd : float
        Mass transfer coefficient.
    kf : float
        Mass transfer coefficient.
    qm : float
        Mass transfer coefficient.
    ip : Optional[Callable]
        Injection profile function. Should be a reference to a function which
        determines the scale of the input c0 as a function of time. Can be
        `None` resulting in a constant injection.
    """

    c0: float
    Dax: float
    Dp: float
    Ds: float
    ka: float
    kd: float
    kf: float
    qm: float
    ip: Optional[Callable[[float], float]] = None


@dataclass
class Solution:
    y_len: int  # Length of solution vector
    tmax: int  # Final time
    dt: float  # Timestep
    nz2: int
    nr2: int
    nc: int
    c_inj_idx: int  # Row index of injection
    zs: np.ndarray  # Collocation points z
    tsize: int = field(init=False)  # Total size of t vector
    y: np.ndarray = field(init=False)  # State vector
    c: np.ndarray = field(init=False)  # Mobile phase concentration
    cp: np.ndarray = field(init=False)  # Mobile phase concentration in pores
    q: np.ndarray = field(init=False)  # Stationary phase concentration
    t: np.ndarray = field(init=False)  # Timesteps

    def __post_init__(self):
        self.tsize = int(self.tmax / self.dt)
        self.y = np.zeros((self.y_len, self.tsize))
        self.c = np.zeros((self.nc, self.nz2, self.tsize))
        self.cp = np.zeros((self.nc, self.nz2, self.nr2, self.tsize))
        self.q = np.zeros((self.nc, self.nz2, self.nr2, self.tsize))
        self.t = np.linspace(0, self.tmax, self.tsize)

    def build_results(self):
        c_inj_idx = self.c_inj_idx
        c_idx = c_inj_idx + 1
        c_end = c_idx + self.nz2
        cp_idx = c_end
        cp_end = c_end + self.nz2 * self.nr2
        q_idx = cp_end
        q_end = cp_end + self.nz2 * self.nr2
        for i in range(self.nc):
            self.c[i, :, :] = self.y[c_idx + i * q_end : i * q_end + c_end, :]
            for j in range(self.nz2):
                self.cp[i, j, :, :] = self.y[
                    i * q_end
                    + c_end
                    + j * self.nr2 : i * q_end
                    + c_end
                    + (j + 1) * self.nr2,
                    :,
                ]

                self.q[i, j, :, :] = self.y[
                    i * q_end
                    + c_end
                    + j * self.nr2 : i * q_end
                    + c_end
                    + (j + 1) * self.nr2,
                    :,
                ]


@dataclass
class GeneralRateModel:
    # Column specific parameters
    u: float  # Average velocity
    ep: float  # Particle porosity, ratio of pore volume to total particle volume
    ec: float  # Column porosity, ratio of interstitial volume to total column volume
    zl: float  # Length column z
    rp: float  # Radius particle r
    nz: int  # Points in column z excluding boundary points
    nr: int  # Points in particle r excluding boundary points

    component_parameters: List[
        ModelParameters
    ]  # List of coefficients for every component

    # Store each model parameter
    Dax: np.ndarray = field(init=False)  # Axial dispersion coefficient
    Dp: np.ndarray = field(init=False)  # Diffusion coefficient in particles
    Ds: np.ndarray = field(init=False)  # Surface diffusion
    ka: np.ndarray = field(init=False)
    kd: np.ndarray = field(init=False)
    kf: np.ndarray = field(init=False)
    c0: np.ndarray = field(init=False)
    ip: List[Optional[Callable[[float], float]]] = field(init=False)

    nz2: int = field(init=False)  # Points in column z including boundary points
    nr2: int = field(init=False)  # Points in particle r including boundary points

    nz2nr2: int = field(init=False)  # Points in particle r including boundary points
    nc: int = field(init=False)  # Number of components

    c_inj_idx: int = field(init=False)  # Index of concentration injection
    c_idx: int = field(init=False)  # Starting index of c vector
    cp_idx: int = field(init=False)  # Starting index of cp vector
    q_idx: int = field(init=False)  # Starting index of qd vector

    c_end: int = field(init=False)  # End index of c vector
    cp_end: int = field(init=False)  # End index of cp vector
    q_end: int = field(init=False)  # End index of qd vector
    y_len: int = field(init=False)  # Length of solution vector

    Ac: np.ndarray = field(init=False)  # First derivative operator z axis
    Bc: np.ndarray = field(init=False)  # Second derivative operator z axis
    Ar: np.ndarray = field(init=False)  # First derivative operator r axis
    Br: np.ndarray = field(init=False)  # Second derivative operator r axis
    sol: Solution = field(init=False)  # Solution structure

    def __post_init__(self):
        self.nz2 = self.nz + 2
        self.nr2 = self.nr + 2
        self.nz2nr2 = self.nz2 * self.nr2
        self.nc = len(self.component_parameters)

        self.c_inj_idx = 0
        self.c_idx = self.c_inj_idx + 1
        self.c_end = self.c_idx + self.nz2

        self.cp_idx = self.c_end
        self.cp_end = self.c_end + self.nz2 * self.nr2

        self.q_idx = self.cp_end
        self.q_end = self.cp_end + self.nz2 * self.nr2

        self.y_len = self.q_end * self.nc

        ocz = occ.OrthColloc(
            self.nz,
            TType=occ.Typ.Lobatto.value,
            Geometry=occ.Geom.Nonsymmetric.value,
            Shift=True,
        )
        self.z = ocz.Xpoints().copy() * self.zl
        self.Ac = ocz.Deriv1().copy() / self.zl
        self.Bc = ocz.Deriv2().copy() / self.zl**2

        ocr = occ.OrthColloc(
            self.nr,
            TType=occ.Typ.Lobatto.value,
            Geometry=occ.Geom.Nonsymmetric.value,
            Shift=True,
        )
        self.r = ocr.Xpoints().copy() * self.rp
        self.r[0] = 1e-12  # No zero in center of particle
        self.Ar = ocr.Deriv1().copy() / (self.rp)
        self.Br = ocr.Deriv2().copy() / (self.rp) ** 2

        self.c0 = np.zeros(self.nc)
        self.Dax = np.zeros(self.nc)
        self.Dp = np.zeros(self.nc)
        self.Ds = np.zeros(self.nc)
        self.ka = np.zeros(self.nc)
        self.kd = np.zeros(self.nc)
        self.kf = np.zeros(self.nc)
        self.qm = np.zeros(self.nc)
        self.ip = []

        for i in range(self.nc):
            self.c0[i] = self.component_parameters[i].c0
            self.Dax[i] = self.component_parameters[i].Dax
            self.Dp[i] = self.component_parameters[i].Dp
            self.Ds[i] = self.component_parameters[i].Ds
            self.ka[i] = self.component_parameters[i].ka
            self.kd[i] = self.component_parameters[i].kd
            self.kf[i] = self.component_parameters[i].kf
            self.qm[i] = self.component_parameters[i].qm
            if self.component_parameters[i].ip:
                self.ip.append(self.component_parameters[i].ip)

    def init_solution(self, tmax: int, dt: float) -> np.ndarray:
        self.sol = Solution(
            self.y_len, tmax, dt, self.nz2, self.nr2, self.nc, self.c_inj_idx, self.z
        )
        return self.sol.y


def _build_component_matrix(
    model: GeneralRateModel, i: int, binding_ratio: np.ndarray
) -> np.ndarray:
    C = np.zeros((model.q_end, model.q_end))
    betap = model.ep / (1 - model.ep)
    betac = model.ec / (1 - model.ec)
    # C[model.c_inj_idx, model.c_inj_idx] = 1.
    # C[model.c_inj_idx, model.c_idx] = -1

    # Build dcdt
    M = model.Dax[i] * model.Bc - model.u * model.Ac

    # Boundary condition
    M[0, :] = model.Dax[i] * model.Ac[0, :] / model.u
    M[0, 0] = -1.0 + model.Dax[i] * model.Ac[0, 0] / model.u
    M[-1, :] = -model.Ac[-1, :]
    # COPY dcdt

    C[model.c_idx : model.c_end, model.c_idx : model.c_end] = M.copy()
    C[model.c_idx, model.c_inj_idx] = 1.0

    # Column interface with particles (jfi)
    for row in range(1, model.nz2 - 1):
        C[model.c_idx + row, model.c_end + model.nr2 * row + model.nr2 - 1] += (
            (1 / betac) * (3 / model.rp) * model.kf[i]
        )
    C[model.c_idx + 1 : model.c_end - 1, model.c_idx + 1 : model.c_end - 1] -= (
        np.eye(model.nz) * (1 / betac) * (3 / model.rp) * model.kf[i]
    )

    # Differentiation stencil for particle
    P = np.zeros((model.nr2, model.nr2))
    for k in range(1, model.nr + 1):
        P[k, :] = model.Dp[i] * (model.Br[k, :] + (2 / model.r[k]) * model.Ar[k, :])
        # q adsorption
    # P[1:model.nr2 - 1, 1:model.nr2 -
    #   1] -= (1 / betap) * model.ka[i] * model.qm[i] * binding_ratio[
    #       1:model.nr2 - 1, 1:model.nr2 - 1]
    # Boundary conditions
    P[0, :] = -model.Ar[0, :]
    P[-1, :-1] = -(model.ep * model.Dp[i]) * model.Ar[-1, :-1]
    P[-1, -1] = -model.kf[i] - (model.ep * model.Dp[i]) * model.Ar[-1, -1]
    # Particle interface with column
    for p in range(0, model.nz2):
        C[model.cp_idx + (p + 1) * model.nr2 - 1, model.c_idx + p] = model.kf[i]

    # Stationary phase interface
    Q = np.eye(model.nr2) * (1 / betap) * model.kd[i]
    Q[0, :] = 0
    Q[-1, :] = 0
    # STAMP P FOR EVERY PARTICLE
    for p in range(0, model.nz2):
        C[
            model.cp_idx + p * model.nr2 : model.cp_idx + (p + 1) * model.nr2,
            model.cp_idx + p * model.nr2 : model.cp_idx + (p + 1) * model.nr2,
        ] += P[:, :]
        C[
            model.cp_idx + p * model.nr2 : model.cp_idx + (p + 1) * model.nr2,
            model.q_idx + p * model.nr2 : model.q_idx + (p + 1) * model.nr2,
        ] += Q[:, :]

        C[
            1 + model.cp_idx + p * model.nr2 : model.cp_idx + (p + 1) * model.nr2 - 1,
            1 + model.cp_idx + p * model.nr2 : model.cp_idx + (p + 1) * model.nr2 - 1,
        ] -= (
            (1 / betap)
            * model.ka[i]
            * model.qm[i]
            * binding_ratio[
                1 + p * model.nr2 : (p + 1) * model.nr2 - 1,
                1 + p * model.nr2 : (p + 1) * model.nr2 - 1,
            ]
        )
    # dqdt
    C[model.q_idx : model.q_end, model.cp_idx : model.cp_end] += (
        model.ka[i] * model.qm[i] * binding_ratio * np.eye(model.nz2nr2)
    )
    C[model.q_idx : model.q_end, model.q_idx : model.q_end] -= model.kd[i] * np.eye(
        model.nz2nr2
    )
    return C


def _binding_site_ratio_per_particle(model: GeneralRateModel, y: np.ndarray):
    """The ratio is (1 - sum of every q for every component in that point on the particle)"""
    ratio = np.eye(model.nz2nr2)
    for j in range(model.nc):
        # Get q for each particle
        qj = (
            np.diag(
                y[model.q_idx + (j * model.q_end) : model.q_end + (j * model.q_end)]
            )
            / model.qm[j]
        )
        qj[0, :] = 0
        qj[-1, :] = 0
        ratio -= qj
    return ratio


def _assemble_complete_matrix(model: GeneralRateModel, y: np.ndarray) -> np.ndarray:
    S = np.zeros((model.y_len, model.y_len))
    binding_ratio = _binding_site_ratio_per_particle(model, y)
    for i in range(model.nc):
        S[
            model.q_end * i : model.q_end * (i + 1),
            model.q_end * i : model.q_end * (i + 1),
        ] = _build_component_matrix(model, i, binding_ratio)
    return S


def _create_lhs_matrix(model: GeneralRateModel, dt: float) -> np.ndarray:
    J = np.eye(model.y_len) / dt
    for i in range(model.nc):
        C = np.eye(model.q_end) / dt
        C[model.c_inj_idx, model.c_inj_idx] = dt
        C[model.c_idx, :] = 0
        C[model.c_end - 1, :] = 0
        for p in range(0, model.nz2):
            C[model.cp_idx + (p + 1) * model.nr2 - 1, :] = 0

        J[
            model.q_end * i : model.q_end * (i + 1),
            model.q_end * i : model.q_end * (i + 1),
        ] = C
    return J


def solve(model: GeneralRateModel, tmax: int, dt: float):
    y = model.init_solution(tmax, dt)
    tsteps = int(tmax / dt)
    Wh = csc_matrix(_create_lhs_matrix(model, dt))
    S = csc_matrix(_assemble_complete_matrix(model, y[:, 0]))
    J = linalg.splu(Wh - S)
    idx = 0
    yt = y[:, 0].copy()
    for t in range(0, tsteps - 1):

        if model.nc > 1:
            S = csc_matrix(_assemble_complete_matrix(model, yt))
            J = linalg.splu(Wh - S)
        # LOADING
        for i in range(model.nc):
            if model.ip and i < len(model.ip) and isinstance(model.ip[i], Callable):
                yt[model.c_inj_idx + i * model.q_end] = (
                    model.ip[i](t * dt) * model.c0[i]
                )

        r = S.dot(yt)
        yt += J.solve(r)
        y[:, t + 1] = yt
    model.sol.build_results()
    return model.sol
